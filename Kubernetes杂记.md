##### 控制器：
pod是kubernetes的最小控制单位，是对容器的进一步抽象和封装，在对容器进行组合的基础上又添加了更多的属性和字段，使得更轻松地操作它。操作这些pod的逻辑则由控制器完成，比较重要的有对pod状态、数量的控制，比如声明的deployment中通过指定replicas的数量，deployment则会一直控制对应的replicas的数量在声明的期待值。
控制器之所以被统一放在k8s项目pkg/controller目录下，就是因为它们都遵循Kubernetes项目中的一个通用编排模式，即：控制循环（control loop）。控制循环的普遍逻辑是在自己的生命周期内（通常由用户控制，maybe infinite loop）获取当前控制对象的实际状态，通过与声明期待状态对比，确认是否需要执行编排动作及动作内容。具体实现中，实际状态旺旺来自于kubernetes集群本身；而期待状态，一般来自用户提交的yaml文件。编排过程叫做调谐（reconcile）。通过定义控制器的api暴露函数，实现自定义的控制器（如deployment）是kubernetes“面向api对象编程”的体现。提交的yaml中上半部分提供了控制器的定义，加上下半部分被控制对象的模板组成。
##### 无状态应用（Deployment）：
##### StatefulSet：
把真实世界的应用状态抽象了两种情况，**拓扑状态**（意味多实例间不完全对等的关系，应用实例必须按照某些顺序启动，比如应用的主节点A先于节点B启动。如果删除AB节点也是按顺序删除。还有如新老pod的网络标识需要一致，这样访问者才能用相同的方法访问到新pod）、**储存状态**（比如数据库应用的多个储存实例）。
声明式API与Kubernetes编程范式：
所谓“声明式”，指的就是我只需要提交一个定义好的 API 对象来“声明”（这个 YAML 文件其实就是一种“声明”），表示所期望的最终状态是什么样子就可以了。而如果提交的是一个个命令，去指导怎么一步一步达到期望状态，这就是“命令式”了。“命令式 API”接收的请求只能一个一个实现，否则会有产生冲突的可能；“声明式API”一次能处理多个写操作，并且具备 Merge 能力。
在Kubernetes项目中，一个API对象在Etcd里的完整资源路径，是由：Group（API组）、Version（API版本）和Resource（API资源类型）三个部分组成的。通过这样的结构，整个Kubernetes里的所有API对象，实际上就可以用如下的树形结构表示出来：
